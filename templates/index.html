<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>å°é²¸çš„æµ·åº•èŠå¤©å®¤ğŸ³</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- æ›¿æ¢recorder-jsä¸ºæ ‡å‡†çš„recorder.js -->
  <script src="/static/js/recorder.js"></script>
  <style>
    body {
      margin: 0;
      font-family: 'Comic Sans MS', 'Segoe UI', sans-serif;
      overflow: hidden;
      background: #8cdff3;
      position: relative;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 30px;
      color: #fff;
      z-index: 10;
      position: relative;
    }

    h2 {
      text-align: center;
      color: #fff;
      text-shadow: 0 2px 4px rgba(0,0,0,0.4);
    }

    #chatHistory {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      padding: 20px;
      min-height: 300px;
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 20px;
      box-shadow: inset 0 0 10px rgba(255,255,255,0.2);
    }

    .user, .bot {
      margin-bottom: 15px;
      animation: fadeIn 0.5s ease;
    }

    .user { color: #ffffee; }
    .bot { color: #d2f5ff; }

    .meta {
      font-size: 0.9em;
      color: #ccf;
      margin-top: -10px;
      margin-bottom: 10px;
    }

    input, button {
      font-size: 1em;
      padding: 12px;
      width: 100%;
      border: none;
      border-radius: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    input { margin-bottom: 10px; }

    button {
      background: #4fd0e9;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s ease;
      margin-bottom: 10px;
    }

    button:hover {
      background: #2ca6c3;
    }

    .voice-btn {
      background: #f091e4;
    }

    .voice-btn:hover {
      background: #c564bd;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
    }
    
    .button-group button {
      flex: 1;
    }

    .error-message {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #e74c3c;
      color: #fff;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 1000;
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .bubble {
      position: absolute;
      bottom: -100px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      animation: floatUp 20s infinite ease-in;
    }

    @keyframes floatUp {
      0% { transform: translateY(0) scale(1); }
      100% { transform: translateY(-150vh) scale(1.5); }
    }

    .bubbles {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 0;
      pointer-events: none;
    }

    .whale {
      position: fixed;
      bottom: 30px;
      left: -100px;
      width: 100px;
      z-index: 2;
      animation: swim 12s linear infinite;
    }

    @keyframes swim {
      0% { left: -120px; transform: scaleX(1); }
      50% { left: 100%; transform: scaleX(1); }
      51% { transform: scaleX(-1); }
      100% { left: -120px; transform: scaleX(-1); }
    }

    .ripple {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at 50% 120%, rgba(255,255,255,0.15), transparent 70%);
      background-size: 100% 200%;
      animation: rippleWave 5s infinite ease-in-out;
      z-index: 0;
    }

    @keyframes rippleWave {
      0%, 100% { background-position: 50% 120%; }
      50% { background-position: 50% 100%; }
    }
  </style>
</head>
<body>
  <!-- åŠ¨æ€èƒŒæ™¯ -->
  <div class="ripple"></div>
  <div class="bubbles">
    <div class="bubble" style="left: 10%; width: 20px; height: 20px; animation-delay: 0s;"></div>
    <div class="bubble" style="left: 30%; width: 40px; height: 40px; animation-delay: 4s;"></div>
    <div class="bubble" style="left: 50%; width: 25px; height: 25px; animation-delay: 2s;"></div>
    <div class="bubble" style="left: 70%; width: 35px; height: 35px; animation-delay: 6s;"></div>
    <div class="bubble" style="left: 90%; width: 20px; height: 20px; animation-delay: 1s;"></div>
  </div>

  <!-- æ¸¸åŠ¨é²¸é±¼ -->
  <img src="https://cdn.pixabay.com/photo/2020/10/18/20/40/whale-5666115_1280.png" class="whale" alt="Whale" />

  <div class="container">
    <h2>ğŸ¬ å°é²¸æ­£åœ¨æµ·åº•ç­‰ä½ è¯´è¯å“¦~</h2>
    <div id="chatHistory"></div>
    <input type="text" id="msgInput" placeholder="å¿«æ¥å’Œå°é²¸èŠå¤©å§ï¼" />
    <div class="button-group">
      <button onclick="send()">å‘é€</button>
      <button id="recordButton" class="voice-btn">ğŸ¤ å¼€å§‹å½•éŸ³</button>
    </div>
    <div id="recordingStatus" style="display:none; color: #fff; text-align: center; margin-top: 10px;">
      æ­£åœ¨å½•éŸ³... <span id="recordingTime">0</span>ç§’
    </div>
  </div>
  
  <!-- éŸ³æ•ˆ -->
  <audio id="sendSound" src="https://cdn.pixabay.com/audio/2023/03/30/audio_e7f183f4f7.mp3" preload="auto"></audio>

  <script>
    const chatHistory = document.getElementById("chatHistory");
    const sendSound = document.getElementById("sendSound");
    const msgInput = document.getElementById("msgInput");
    const recordButton = document.getElementById("recordButton");
    const recordingStatus = document.getElementById("recordingStatus");
    const recordingTime = document.getElementById("recordingTime");

    let audioContext;
    let recorder;
    let audioStream;
    let isRecording = false;
    let recordingTimer;
    let recordingSeconds = 0;

    // æ˜¾ç¤ºé”™è¯¯æç¤º
    function showError(message) {
      const errorDiv = document.createElement("div");
      errorDiv.className = "error-message";
      errorDiv.textContent = message;
      document.body.appendChild(errorDiv);
      setTimeout(() => errorDiv.remove(), 5000);
    }

    // å‘é€èŠå¤©æ¶ˆæ¯
    async function send(msgOverride = null) {
      const msg = msgOverride || msgInput.value.trim();
      if (!msg) return;

      chatHistory.innerHTML += `<div class="user"><strong>ä½ :</strong> ${msg}</div>`;
      msgInput.value = "";
      sendSound.play();

      try {
        const res = await fetch("/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message: msg })
        });
        const data = await res.json();
        chatHistory.innerHTML += `<div class="bot"><strong>å°é²¸:</strong> ${data.reply}</div>`;
        chatHistory.scrollTop = chatHistory.scrollHeight;
      } catch (err) {
        showError("å‘é€æ¶ˆæ¯å¤±è´¥: " + err.message);
      }
    }

    // å½•éŸ³åˆ‡æ¢
    function toggleRecording() {
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    }

    // å¼€å§‹å½•éŸ³ - ä½¿ç”¨æ–°çš„recorder.js
    async function startRecording() {
      try {
        // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: 16000 // è®¾ç½®é‡‡æ ·ç‡ä¸º16kHz
        });
        
        // è·å–éº¦å…‹é£æµ
        audioStream = await navigator.mediaDevices.getUserMedia({ 
          audio: { 
            sampleRate: 16000,
            channelCount: 1,
            echoCancellation: true,
            noiseSuppression: true
          } 
        });
        
        // åˆ›å»ºéŸ³é¢‘è¾“å…¥èŠ‚ç‚¹
        const source = audioContext.createMediaStreamSource(audioStream);
        
        // åˆ›å»ºRecorderå®ä¾‹
        recorder = new Recorder(source, {
          numChannels: 1, // å•å£°é“
          sampleRate: 16000 // 16kHzé‡‡æ ·ç‡
        });
        
        // å¼€å§‹å½•éŸ³
        recorder.record();
        
        // æ›´æ–°UI
        isRecording = true;
        recordButton.textContent = "ğŸ›‘ åœæ­¢å½•éŸ³";
        recordButton.style.background = "#e74c3c";
        recordingStatus.style.display = "block";

        // å¼€å§‹è®¡æ—¶
        recordingSeconds = 0;
        recordingTime.textContent = recordingSeconds;
        recordingTimer = setInterval(() => {
          recordingSeconds++;
          recordingTime.textContent = recordingSeconds;
          if (recordingSeconds >= 60) {
            stopRecording();
            showError("å½•éŸ³æ—¶é—´è¾¾åˆ°60ç§’ä¸Šé™");
          }
        }, 1000);
        
        console.log("å¼€å§‹å½•éŸ³ï¼Œä½¿ç”¨æ ‡å‡†WAVæ ¼å¼");
      } catch (err) {
        showError("æ— æ³•è®¿é—®éº¦å…‹é£: " + err.message);
        console.error("å½•éŸ³é”™è¯¯:", err);
      }
    }

    // åœæ­¢å½•éŸ³
    function stopRecording() {
      if (!isRecording || !recorder) return;
      
      // åœæ­¢å½•éŸ³
      recorder.stop();
      
      // åœæ­¢éº¦å…‹é£è®¿é—®
      if (audioStream) {
        audioStream.getTracks().forEach(track => track.stop());
      }
      
      // æ›´æ–°UI
      isRecording = false;
      recordButton.textContent = "ğŸ¤ å¼€å§‹å½•éŸ³";
      recordButton.style.background = "#f091e4";
      recordingStatus.style.display = "none";
      clearInterval(recordingTimer);
      
      // å¯¼å‡ºWAV
      recorder.exportWAV(blob => {
        console.log("å½•éŸ³å®Œæˆï¼ŒWAVæ ¼å¼ï¼Œå¤§å°:", blob.size, "å­—èŠ‚");
        sendAudioToServer(blob);
      }, 'audio/wav');
    }

    // å‘é€éŸ³é¢‘åˆ°æœåŠ¡å™¨
    async function sendAudioToServer(audioBlob) {
      if (audioBlob.size > 10 * 1024 * 1024) {
        showError("éŸ³é¢‘æ–‡ä»¶è¿‡å¤§ï¼Œè¯·ç¼©çŸ­å½•éŸ³æ—¶é—´");
        return;
      }

      // åˆ›å»ºä¸€ä¸ªreaderè¯»å–blobå†…å®¹ï¼Œç”¨äºè°ƒè¯•
      const reader = new FileReader();
      reader.onload = function() {
        const arrayBuffer = this.result;
        // æ£€æŸ¥WAVå¤´éƒ¨
        const dataView = new DataView(arrayBuffer);
        const header = new Uint8Array(arrayBuffer, 0, 12);
        console.log("WAVå¤´éƒ¨æ£€æŸ¥:", 
          String.fromCharCode(header[0], header[1], header[2], header[3]), // åº”è¯¥æ˜¯"RIFF"
          String.fromCharCode(header[8], header[9], header[10], header[11]) // åº”è¯¥æ˜¯"WAVE"
        );
      };
      reader.readAsArrayBuffer(audioBlob);

      // ä½¿ç”¨FormDataå‘é€
      const formData = new FormData();
      formData.append("audio", audioBlob, "audio.wav");

      try {
        msgInput.placeholder = "æ­£åœ¨å¤„ç†è¯­éŸ³...";
        msgInput.disabled = true;

        // æ”¹ä¸ºä½¿ç”¨base64å‘é€ï¼Œä¸åç«¯åŒ¹é…
        const base64Reader = new FileReader();
        base64Reader.readAsDataURL(audioBlob);
        base64Reader.onloadend = async () => {
          const base64Audio = base64Reader.result;
          
          const response = await fetch("/speech-to-text", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ audio: base64Audio })
          });

          const result = await response.json();

          msgInput.disabled = false;
          msgInput.placeholder = "å¿«æ¥å’Œå°é²¸èŠå¤©å§ï¼";

          if (result.error) {
            let errorMsg = "è¯­éŸ³è¯†åˆ«å¤±è´¥: " + result.error;
            if (result.saved_file) {
              errorMsg += "\nå½•éŸ³å·²ä¿å­˜åˆ°: " + result.saved_file;
            }
            showError(errorMsg);
          } else if (result.text) {
            msgInput.value = result.text;
            send(result.text);
            if (result.saved_file) {
              console.log("å½•éŸ³å·²ä¿å­˜åˆ°: " + result.saved_file);
            }
          }
        };
      } catch (err) {
        msgInput.disabled = false;
        msgInput.placeholder = "å¿«æ¥å’Œå°é²¸èŠå¤©å§ï¼";
        showError("å¤„ç†è¯­éŸ³æ—¶å‡ºé”™: " + err.message);
      }
    }

    // å›è½¦é”®å‘é€
    msgInput.addEventListener("keypress", function(event) {
      if (event.key === "Enter") {
        event.preventDefault();
        send();
      }
    });

    // ç»‘å®šå½•éŸ³æŒ‰é’®
    recordButton.addEventListener("click", toggleRecording);
  </script>
</body>
</html>